<!doctype html>
<html lang = 'en'>
  <head>
    <meta charset = 'utf-8'>
    
    <title>coolguy284.com: Juicy Queenbeet Hole-Punch Calculator</title>
    
    <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0'>
    <meta name = 'description' content = 'Calculates optimal hole-punch locations for a 6x6 field of Queenbeets to maximize Juicy Queenbeet spawn chance ticks in the game Cookie Clicker.'>
    <meta name = 'keywords' content = 'Cookie Clicker, Juicy Queenbeet'>
    <meta name = 'author' content = 'coolguy284'>
    
    <link rel = 'canonical' href = 'https://coolguy284.com/debug/juicy_queenbeet_hole_punch.html'>
    
    <meta name = 'og:title' content = 'coolguy284.com: Juicy Queenbeet Hole-Punch Calculator'>
    <meta name = 'og:description' content = 'Calculates optimal hole-punch locations for a 6x6 field of Queenbeets to maximize Juicy Queenbeet spawn chance ticks in the game Cookie Clicker.'>
    <meta name = 'og:type' content = 'website'>
    <meta name = 'og:url' content = 'https://coolguy284.com/debug/juicy_queenbeet_hole_punch.html'>
    
    <link rel = 'stylesheet' href = '/libs/extern/bootstrap_5.0.0.min.css'>
    <style>
      textarea {
        font-family: monospace;
        height: 200px;
      }
      
      #results {
        font-family: monospace;
        white-space: pre;
      }
    </style>
  </head>
  
  <body>
    <div class = 'container mt-3'>
      <noscript>
        <div class = 'alert alert-warning' role = 'alert' style = 'padding: 0.5rem 2rem 0.5rem;'>
          Note: This has obvious active components and thus requires JavaScript to function (JavaScript is disabled).
        </div>
      </noscript>
      
      <h1>Cookie Clicker Juicy Queenbeet Hole-Punch Calculator</h1>
      
      <p>Calculates optimal hole-punch locations for a 6x6 field of Queenbeets to maximize Juicy Queenbeet spawn chance ticks in the game Cookie Clicker.</p>
      
      <textarea id = 'jqb_data' class = 'form-control'></textarea>
      
      <br>
      
      <div class = 'form-check'>
        <label for = 'seedless_to_nay_gotten' class = 'form-check-label'>
          Seedless to Nay Achievement Unlocked
        </label>
        
        <input type = 'checkbox' id = 'seedless_to_nay_unlocked' class = 'form-check-input'>
      </div>
      
      <br>
      
      <button id = 'calculate_btn' class = 'btn btn-primary'>Calculate</button>
      
      <p class = 'mt-3'>Results:</p>
      <p id = 'results'></p>
    </div>
    
    <script type = 'module'>
      const JQB_DATA_ELEM = jqb_data;
      const STN_UNLOCKED_CHECK = seedless_to_nay_unlocked;
      const CALCULATE_BTN = calculate_btn;
      const RESULT_ELEM = results;
      
      // Next 2 constants might need to be incremented by 1
      
      /**
       * The length of ticks a Juicy Queenbeet is mature when the "Seedless to nay" achievment is not unlocked.
       * @constant
       * @type {integer}
       */
      const JQB_MATURE_TICKS_NO_STN = 16; // Might be 17
      
      /**
       * The length of ticks a Juicy Queenbeet is mature when the "Seedless to nay" achievment is unlocked.
       * @constant
       * @type {integer}
       */
      const JQB_MATURE_TICKS_STN = 19; // Might be 20
      
      /**
       * The [x, y] offsets that make up the Moore neighborhood of a point.
       * @constant
       * @type {Array<Array<integer>>}
       */
      const MOORE_NEIGHBORHOOD_OFFSETS = [
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, -1],
        [0, 1],
        [1, -1],
        [1, 0],
        [1, 1],
      ];
      
      class InputError extends Error {}
      
      function getMatureTicks(seedlessToNayUnlocked) {
        return seedlessToNayUnlocked ?
          JQB_MATURE_TICKS_STN :
          JQB_MATURE_TICKS_NO_STN;
      }
      
      /**
       * Parses a string containing Juicy Queenbeet age data into an intermediate representation. Errors if string is invalid.
       * 
       * @param {Boolean} seedlessToNayUnlocked - True if achievement "Seedless to nay" is unlocked.
       * 
       * @param {string} jqbData - The string containing Juicy Queenbeet age data. Format:
       * Rectangular grid of entries, seperated by spaces horizontally and newlines vertically.
       * Each entry is an integer representing garden ticks till next stage. If plant is in bloom phase, a "B" is prefixed to the integer. If the plant is not a Queenbeet or is empty, an "-" is used and no integer is included.
       * 
       * @returns {{ garden: Array<integer>, gardenWidth: integer }} {
       *   garden: Array<integer | null>,
       *     Each entry in the array is the ticks till decay of a single Queenbeet in the garden, or null if there is no Queenbeet there. Array is 1-dimensional, and contents are left-to-right, top-to-bottom representation of garden.
       *   gardenWidth: integer,
       *     Width of the garden.
       * }
       */
      function parseJQBData(seedlessToNayUnlocked, jqbData) {
        const garden2dWithLineNums =
          jqbData
            .split('\n')
            .map((line, index) => [index + 1, line]) // map to [line number, content]
            .filter(([_lineNumber, line]) => line != '')
            .map(
              ([lineNumber, line]) => [
                lineNumber,
                line,
                line
                  .split(/ +/g)
                  .filter(plantAgeData => plantAgeData != '')
                  .map(plantAgeData => {
                    if (plantAgeData == '-') {
                      return null;
                    } else {
                      let numberString;
                      let beforeMaturity;
                      
                      if (plantAgeData.startsWith('B')) {
                        numberString = plantAgeData.slice(1);
                        beforeMaturity = true;
                      } else {
                        numberString = plantAgeData;
                        beforeMaturity = false;
                      }
                      
                      const ticksTillNextStage = Number(numberString);
                      
                      if (!Number.isSafeInteger(ticksTillNextStage)) {
                        throw new InputError(`plantAgeData invalid: not small integer: ${JSON.stringify(ticksTillNextStage)} (line #${lineNumber}: ${JSON.stringify(line)})`);
                      }
                      
                      if (ticksTillNextStage < 0) {
                        throw new InputError(`plantAgeData invalid: not in range: ${JSON.stringify(ticksTillNextStage)} (line #${lineNumber}: ${JSON.stringify(line)})`);
                      }
                      
                      return (
                          beforeMaturity ?
                            getMatureTicks(seedlessToNayUnlocked) :
                            0
                        ) +
                          ticksTillNextStage;
                    }
                  }),
              ]
            );
        
        const gardenRowLengths = garden2dWithLineNums.map(([lineNumber, line, row]) => [lineNumber, line, row.length]);
        
        if (gardenRowLengths.length > 1) {
          const firstRowLength = gardenRowLengths[0][2];
          
          for (let i = 1; i < gardenRowLengths.length; i++) {
            const [ lineNumber, line, rowLength ] = gardenRowLengths[i];
            
            if (rowLength != firstRowLength) {
              throw new InputError(`jqbData invalid: row length ${rowLength} != first row length ${firstRowLength} (line #${lineNumber}: ${JSON.stringify(line)})`);
            }
          }
        }
        
        const garden2d = garden2dWithLineNums.map(([_lineNumber, _line, row]) => row);
        
        return {
          garden: garden2d.flat(),
          gardenWidth: garden2d[0].length,
        }
      }
      
      /**
       * Returns the amount of ticks till decay of the plant that will last the longest before decaying.
       * 
       * @param {Array<integer>} garden - The ticks till decay of every Queenbeet in the garden.
       * 
       * @returns {integer} The ticks till decay of the plant that will last the longest before decaying.
       */
      function getMaxLife(garden) {
        return garden.reduce((a, c) => Math.max(a, c));
      }
      
      /**
       * Returns the amount of ticks till decay of the plant that will last the shortest before decaying.
       * 
       * @param {Array<integer>} garden - The ticks till decay of every Queenbeet in the garden.
       * 
       * @returns {integer} The ticks till decay of the plant that will last the shortest before decaying.
       */
      function getMinLife(garden) {
        return garden.reduce((a, c) => Math.min(a, c));
      }
      
      function generateHolePunchCoords(gardenSize, holeCount) {
        if (holeCount == 0) {
          return [[]];
        } else if (holeCount == 1) {
          return new Array(gardenSize - (holeCount - 1))
            .fill()
            .map((_, i) => [i]);
        } else {
          return new Array(gardenSize - (holeCount - 1))
            .fill()
            .map((_, i) => {
              return generateHolePunchCoords(gardenSize - i - 1, holeCount - 1)
                .map(holeList => {
                  return [
                    i,
                    ...holeList.map(hole => hole + i + 1)
                  ];
                });
            })
            .flat();
        }
      }
      
      function generateUpToHolePunchCoords(gardenSize, maxHoleCount) {
        return new Array(maxHoleCount + 1)
          .fill()
          .map((_, holeCount) => generateHolePunchCoords(gardenSize, holeCount))
          .flat();
      }
      
      function punchHoles(garden, punchCoords) {
        let result = [ ...garden ];
        
        for (const coord of punchCoords) {
          result[coord] = null;
        }
        
        return result;
      }
      
      function getMooreNeighborhoodPlots(garden, gardenWidth, coordX, coordY) {
        return MOORE_NEIGHBORHOOD_OFFSETS
          .map(
            ([ deltaX, deltaY ]) =>
              garden[(coordX + deltaX) + (coordY + deltaY) * gardenWidth]
          );
      }
      
      function splitCoordToXY(gardenWidth, coord) {
        return {
          coordX: coord % gardenWidth,
          coordY: Math.floor(coord / gardenWidth),
        };
      }
      
      function getGardenHeight(garden, gardenWidth) {
        return Math.round(garden.length / gardenWidth);
      }
      
      function findMaxMutateSetups(seedlessToNayUnlocked, garden, gardenWidth) {
        const gardenHeight = getGardenHeight(garden, gardenWidth);
        const maxHolesPossibleX = Math.floor((gardenWidth - 1) / 2);
        const maxHolesPossibleY = Math.floor((gardenHeight - 1) / 2);
        const maxHolesPossible = maxHolesPossibleX * maxHolesPossibleY;
        const matureTicks = getMatureTicks(seedlessToNayUnlocked);
        
        const holePunchCoordSets = generateUpToHolePunchCoords(garden.length, maxHolesPossible);
        
        const holeMutationTicks =
          holePunchCoordSets
            .map(punchCoords => {
              const punchedGarden = punchHoles(garden, punchCoords);
              
              let totalMutationTicks = 0;
              
              for (const coord of punchCoords) {
                const { coordX, coordY } = splitCoordToXY(gardenWidth, coord);
                
                // Check basic bounds on hole
                
                if (coordX < 1 || coordX > gardenWidth - 2) {
                  // bad hole
                  continue;
                }
                
                if (coordY < 1 || coordY > gardenHeight - 2) {
                  // bad hole
                  continue;
                }
                
                // Get Moore neighborhood of hole
                
                const mooreGarden = getMooreNeighborhoodPlots(punchedGarden, gardenWidth, coordX, coordY);
                
                // Check that every plot around is valid
                
                if (mooreGarden.some(life => life == null)) {
                  // bad hole
                  continue;
                }
                
                // Hole passes preliminary checks, now calculate life
                
                const maxLife = getMaxLife(mooreGarden);
                let mutationTicks = getMinLife(mooreGarden);
                
                if (maxLife > matureTicks) {
                  mutationTicks -= maxLife - matureTicks;
                }
                
                if (mutationTicks < 0) {
                  mutationTicks = 0;
                }
                
                totalMutationTicks += mutationTicks;
              }
              
              return {
                punchCoords,
                totalMutationTicks,
              };
            });
        
        const bestPunchSetups =
          holeMutationTicks.reduce((a, c) => {
            if (a == null || c.totalMutationTicks > a.totalMutationTicks) {
              return {
                totalMutationTicks: c.totalMutationTicks,
                punchCoordSets: [c.punchCoords],
              };
            } else if (c.totalMutationTicks == a.totalMutationTicks) {
              a.punchCoordSets.push(c.punchCoords);
              return a;
            } else {
              return a;
            }
          }, null);
        
        return {
          setupsChecked: holePunchCoordSets.length,
          ...bestPunchSetups,
        };
      }
      
      function visualizePunchCoords(gardenWidth, gardenHeight, punchCoords) {
        let visualGarden =
          new Array(gardenHeight)
          .fill()
          .map(
            () =>
              new Array(gardenWidth)
                .fill('Q')
          );
        
        for (const coord of punchCoords) {
          const { coordX, coordY } = splitCoordToXY(gardenWidth, coord);
          
          visualGarden[coordY][coordX] = '-';
        }
        
        return visualGarden
          .map(
              visualGardenRow =>
                visualGardenRow
                  .join('')
          )
          .join('\n');
      }
      
      function parseFindPrintMutateSetups(seedlessToNayUnlocked, jqbData) {
        const { garden, gardenWidth } = parseJQBData(seedlessToNayUnlocked, jqbData);
        const gardenHeight = getGardenHeight(garden, gardenWidth);
        
        const {
          setupsChecked,
          totalMutationTicks,
          punchCoordSets,
        } = findMaxMutateSetups(seedlessToNayUnlocked, garden, gardenWidth);
        
        let result = '';
        
        result += `Setups Checked: ${setupsChecked}\n`;
        result += `Maximal Tick Setups: ${punchCoordSets.length}\n`;
        result += `Mutation Ticks: ${totalMutationTicks}\n`;
        result += '\n';
        
        for (const punchCoords of punchCoordSets) {
          result += visualizePunchCoords(gardenWidth, gardenHeight, punchCoords) + '\n';
          result += '\n';
        }
        
        return result;
      }
      
      CALCULATE_BTN.addEventListener('click', () => {
        try {
          RESULT_ELEM.textContent = parseFindPrintMutateSetups(STN_UNLOCKED_CHECK.checked, JQB_DATA_ELEM.value);
        } catch (err) {
          if (!(err instanceof InputError)) {
            console.error(err);
          }
          
          alert(err.toString());
        }
      });
    </script>
  </body>
</html>
