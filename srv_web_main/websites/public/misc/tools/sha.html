<!doctype html>
<html lang = 'en'>
  <head>
    <meta charset = 'utf-8'>
    
    <title>coolguy284.com: SHA / Keccak Hasher</title>
    
    <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0'>
    <meta name = 'description' content = 'This website is used to calculate the SHA or Keccak hash of text.'>
    <meta name = 'keywords' content = 'SHA, SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256, SHA3-224, SHA3-256, SHA3-384, SHA3-512, Keccak-224, Keccak-256, Keccak-384, Keccak-512, SHAKE-128, SHAKE-256, CSHAKE-128, CSHAKE-256'>
    <meta name = 'author' content = 'coolguy284'>
    
    <link rel = 'canonical' href = 'https://coolguy284.com/misc/tools/sha.html'>
    
    <meta name = 'og:title' content = 'coolguy284.com: SHA / Keccak Hasher'>
    <meta name = 'og:description' content = 'This website is used to calculate the SHA or Keccak hash of text.'>
    <meta name = 'og:type' content = 'website'>
    <meta name = 'og:url' content = 'https://coolguy284.com/misc/tools/sha.html'>
    
    <link rel = 'stylesheet' href = '/libs/extern/bootstrap_5.0.0.min.css'>
    <style>
      textarea {
        font-family: monospace;
        height: 200px;
      }
    </style>
  </head>
  <body>
    <div class = 'container-fluid'>
      <noscript>
        <div class = 'alert alert-warning' role = 'alert' style = 'padding: 0.5rem 2rem 0.5rem;'>
          Note: This has obvious active components and thus requires JavaScript to function (JavaScript is disabled).
        </div>
      </noscript>
      
      <div class = 'row mt-2'>
        <div class = 'col-auto mb-2'>
          <select class = 'form-select' id = 'hash_algorythm' oninput = 'Update(1);'>
            <optgroup label = 'SHA1'>
              <option value = 'SHA-1'>SHA-1 (Native)</option>
            </optgroup>
            <optgroup label = 'SHA2'>
              <option value = 'SHA-224'>SHA-224</option>
              <option value = 'SHA-256' selected>SHA-256 (Native)</option>
              <option value = 'SHA-384'>SHA-384 (Native)</option>
              <option value = 'SHA-512'>SHA-512 (Native)</option>
              <option value = 'SHA-512_224'>SHA-512/224</option>
              <option value = 'SHA-512_256'>SHA-512/256</option>
            </optgroup>
            <optgroup label = 'SHA3'>
              <option value = 'SHA3-224'>SHA3-224</option>
              <option value = 'SHA3-256'>SHA3-256</option>
              <option value = 'SHA3-384'>SHA3-384</option>
              <option value = 'SHA3-512'>SHA3-512</option>
            </optgroup>
            <optgroup label = 'Keccak'>
              <option value = 'Keccak-224'>Keccak-224</option>
              <option value = 'Keccak-256'>Keccak-256</option>
              <option value = 'Keccak-384'>Keccak-384</option>
              <option value = 'Keccak-512'>Keccak-512</option>
            </optgroup>
            <optgroup label = 'SHA3-SHAKE'>
              <option value = 'SHAKE-128'>SHAKE-128</option>
              <option value = 'SHAKE-256'>SHAKE-256</option>
            </optgroup>
            <optgroup label = 'SHA3-CSHAKE'>
              <option value = 'CSHAKE-128'>CSHAKE-128</option>
              <option value = 'CSHAKE-256'>CSHAKE-256</option>
            </optgroup>
          </select>
        </div>
        
        <div class = 'col-auto mb-2' style = 'display: none;' id = 'output_length_div'>
          <label class = 'col-form-label' for = 'output_length'>Output Length:</label>
          
          <input type = 'number' class = 'form-control ms-2' id = 'output_length' min = 0 step = 1 value = 256 style = 'width: 7.5rem;' oninput = 'Update();' onkeydown = 'OutputLengthUpdate();'>
        </div>
        
        <div class = 'col-auto flex-sm-nowrap flex-wrap mb-2' style = 'display: none;' id = 'function_name_div'>
          <label class = 'col-form-label flex-shrink-0' for = 'function_name'>Function Name:</label>
          
          <div class = 'input-group ms-2'>
            <div class = 'input-group-text'>
              <input type = 'checkbox' class = 'form-check-input' id = 'function_name_check' aria-label = 'Checkbox to enable function name in CSHAKE hash.' oninput = 'Update();'>
            </div>
            <textarea class = 'form-control' id = 'function_name' placeholder = 'Function name here.' style = 'width: 20rem; height: 2rem; resize: both;' oninput = 'Update();'></textarea>
            <select class = 'form-select' id = 'function_name_format' style = 'width: 12.5rem;' oninput = 'Update();'>
              <option value = 'utf8' selected>UTF-8</option>
              <option value = 'utf16le'>UTF-16 LE</option>
              <option value = 'utf16lenb'>UTF-16 LE (No BOM)</option>
              <option value = 'utf16be'>UTF-16 BE</option>
              <option value = 'utf16benb'>UTF-16 BE (No BOM)</option>
              <option value = 'latin1'>Latin1</option>
              <option value = 'base64'>Base64</option>
              <option value = 'hex'>Hex</option>
            </select>
          </div>
        </div>
        
        <div class = 'col-auto flex-sm-nowrap flex-wrap mb-2' style = 'display: none;' id = 'customization_div'>
          <label class = 'col-form-label flex-shrink-0' for = 'customization'>Customization:</label>
          
          <div class = 'input-group ms-2'>
            <div class = 'input-group-text'>
              <input type = 'checkbox' class = 'form-check-input' id = 'customization_check' aria-label = 'Checkbox to enable customization string in CSHAKE hash.' oninput = 'Update();'>
            </div>
            <textarea class = 'form-control' id = 'customization' placeholder = 'Customization string here.' style = 'width: 20rem; height: 2rem; resize: both;' oninput = 'Update();'></textarea>
            <select class = 'form-select' id = 'customization_format' style = 'width: 12.5rem;' oninput = 'Update();'>
              <option value = 'utf8' selected>UTF-8</option>
              <option value = 'utf16le'>UTF-16 LE</option>
              <option value = 'utf16lenb'>UTF-16 LE (No BOM)</option>
              <option value = 'utf16be'>UTF-16 BE</option>
              <option value = 'utf16benb'>UTF-16 BE (No BOM)</option>
              <option value = 'latin1'>Latin1</option>
              <option value = 'base64'>Base64</option>
              <option value = 'hex'>Hex</option>
            </select>
          </div>
        </div>
        
        <div class = 'col-auto d-flex mb-2'>
          <label class = 'col-form-label flex-shrink-0' for = 'text_encoding'>Text Encoding:</label>
          
          <select class = 'form-select ms-2' id = 'text_encoding' oninput = 'Update(1);'>
            <option value = 'utf8' selected>UTF-8</option>
            <option value = 'utf16le'>UTF-16 LE</option>
            <option value = 'utf16lenb'>UTF-16 LE (No BOM)</option>
            <option value = 'utf16be'>UTF-16 BE</option>
            <option value = 'utf16benb'>UTF-16 BE (No BOM)</option>
            <option value = 'latin1'>Latin1</option>
            <option value = 'base64'>Base64</option>
            <option value = 'hex'>Hex</option>
          </select>
        </div>
        
        <div class = 'col-auto d-flex mb-2'>
          <label class = 'col-form-label flex-shrink-0' for = 'output_encoding'>Output Encoding:</label>
          
          <select class = 'form-select ms-2' id = 'output_encoding' oninput = 'Update(1);'>
            <option value = 'latin1'>Latin1</option>
            <option value = 'base64'>Base64</option>
            <option value = 'hex' selected>Hex</option>
          </select>
        </div>
        
        <div class = 'col-auto d-flex mb-2'>
          <label class = 'col-form-label' for = 'repeats'>Repeat Times:</label>
          
          <input type = 'number' class = 'form-control ms-2' id = 'repeats' min = 1 step = 1 value = 1 style = 'width: 7.5rem;' oninput = 'Update();'>
        </div>
        
        <div class = 'col-auto mb-2'> 
          <button type = 'button' class = 'btn btn-outline-primary' onclick = 'Update(1);'>Hash Text</button>
        </div>
        
        <div class = 'col-auto mb-2'>
          <label class = 'btn btn-outline-primary' for = 'auto_convert'><input type = 'checkbox' class = 'form-check-input me-2' value = '' id = 'auto_convert' oninput = 'Update();' checked>Auto Convert</label>
        </div>
        
        <div class = 'col-auto mb-2'>
          <input type = 'file' id = 'file_to_load' style = 'display: none;' aria-hidden = 'true'>
          
          <div class = 'btn-group'>
            <button type = 'button' class = 'btn btn-outline-primary' onclick = 'SetTextToFile();'>Set Text to File</button>
            <button type = 'button' class = 'btn btn-outline-primary dropdown-toggle dropdown-toggle-split' data-bs-toggle = 'dropdown' aria-expanded = 'false'>
              <span class = 'visually-hidden'>Toggle Set Text to File Extended Options</span>
            </button>
            <ul class = 'dropdown-menu'>
              <li><button type = 'button' class = 'dropdown-item' onclick = 'SetTextToFile();'>Set Text to File</button></li>
              <li><button type = 'button' class = 'dropdown-item' onclick = 'SetHashedTextToFile();'>Set Hashed Text to File</button></li>
            </ul>
          </div>
          
          <div class = 'btn-group'>
            <button type = 'button' class = 'btn btn-outline-primary' onclick = 'DownloadTextAsFile();'>Download Text as File</button>
            <button type = 'button' class = 'btn btn-outline-primary dropdown-toggle dropdown-toggle-split' data-bs-toggle = 'dropdown' aria-expanded = 'false'>
              <span class = 'visually-hidden'>Toggle Download Text as File Extended Options</span>
            </button>
            <ul class = 'dropdown-menu'>
              <li><button type = 'button' class = 'dropdown-item' onclick = 'DownloadTextAsFile();'>Download Text as File</button></li>
              <li><button type = 'button' class = 'dropdown-item' onclick = 'DownloadHashedTextAsFile();'>Download Hashed Text as File</button></li>
            </ul>
          </div>
        </div>
      </div>
      
      <div class = 'card'>
        <div class = 'card-body'>
          <h4 class = 'card-title' style = 'margin-top: -7px;'><label for = 'text_unhashed'>Text</label></h4>
          <div class = 'alert alert-danger' id = 'text_unhashed_warning' style = 'display: none; position: absolute; top: 0.4rem; right: 1rem; padding: 0.2rem 1rem 0.2rem; width: calc(100% - 8rem);'></div>
          <textarea class = 'form-control' id = 'text_unhashed' placeholder = 'Regular text here. Or drag and drop a file here.' oninput = 'Update();'></textarea>
        </div>
      </div>
      
      <div class = 'card'>
        <div class = 'card-body'>
          <h4 class = 'card-title' style = 'margin-top: -7px;'><label id = 'hash_header' for = 'text_hashed'>SHA</label></h4>
          <textarea class = 'form-control' id = 'text_hashed' placeholder = 'SHA hashed text here.'></textarea>
        </div>
      </div>
      
      <br>
    </div>
    
    <script src = '/libs/extern/sha256_0.9.0.min.js' async></script>
    <script src = '/libs/extern/sha512_0.8.0.min.js' async></script>
    <script src = '/libs/extern/sha3_0.8.0.min.js' async></script>
    <script src = '/libs/extern/bootstrap_5.0.0.bundle.min.js' async></script>
    <script>
      // next 2 funcs taken from mozilla, modified
      function Utf8ToLatin1(str) {
        return encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1));
      }
      
      function Latin1ToUtf8(str) {
        return decodeURIComponent(Array.prototype.map.call(str, c => '%' + c.charCodeAt(0).toString(16).padStart(2, '0')).join(''));
      }
      
      function Utf16LEToLatin1(str) {
        return Array.prototype.map.call('\ufeff' + str, c => { c = c.charCodeAt(0); return String.fromCharCode(c % 256, Math.floor(c / 256)); }).join('');
      }
      
      function Latin1ToUtf16LE(str) {
        let arr = [];
        for (var i = 0; i < str.length; i += 2) arr.push(String.fromCharCode(str.charCodeAt(i) + str.charCodeAt(i + 1) * 256));
        arr = arr.join('');
        return arr[0] == '\ufeff' ? arr.slice(1) : arr;
      }
      
      function Utf16LENBToLatin1(str) {
        return Array.prototype.map.call(str, c => { c = c.charCodeAt(0); return String.fromCharCode(c % 256, Math.floor(c / 256)); }).join('');
      }
      
      function Latin1ToUtf16LENB(str) {
        let arr = [];
        for (var i = 0; i < str.length; i += 2) arr.push(String.fromCharCode(str.charCodeAt(i) + str.charCodeAt(i + 1) * 256));
        return arr.join('');
      }
      
      function Utf16BEToLatin1(str) {
        return Array.prototype.map.call('\ufeff' + str, c => { c = c.charCodeAt(0); return String.fromCharCode(Math.floor(c / 256), c % 256); }).join('');
      }
      
      function Latin1ToUtf16BE(str) {
        let arr = [];
        for (var i = 0; i < str.length; i += 2) arr.push(String.fromCharCode(str.charCodeAt(i) * 256 + str.charCodeAt(i + 1)));
        arr = arr.join('');
        return arr[0] == '\ufeff' ? arr.slice(1) : arr;
      }
      
      function Utf16BENBToLatin1(str) {
        return Array.prototype.map.call(str, c => { c = c.charCodeAt(0); return String.fromCharCode(Math.floor(c / 256), c % 256); }).join('');
      }
      
      function Latin1ToUtf16BENB(str) {
        let arr = [];
        for (var i = 0; i < str.length; i += 2) arr.push(String.fromCharCode(str.charCodeAt(i) * 256 + str.charCodeAt(i + 1)));
        return arr.join('');
      }
      
      function BinaryStringToHex(str) {
        return Array.prototype.map.call(str, c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('');
      }
      
      function HexToBinaryString(str) {
        str = str.replace(/[^0-9A-Fa-f]/g, '');
        let arr = [];
        for (var i = 0; i < str.length; i += 2) arr.push(String.fromCharCode(parseInt(str.slice(i, i + 2), 16)));
        return arr.join('');
      }
      
      // html and textarea don't support carriage returns in textareas, they get auto converted to newlines 🙃, so null byte followed by a newline will be counted as a carriage return instead (two null bytes in a row for an actual null byte)
      function TextToTextArea(str) {
        return str.replace(/\x00/g, '\x00\x00').replace(/\r/g, '\x00\n');
      }
      
      // probably some advanced grammar reason why simple replace statements won't cut it here
      function TextAreaToText(str) {
        let result = '', i = 0;
        for (; i < str.length - 1; i++) {
          if (str.charCodeAt(i) == 0) {
            if (str[i + 1] == '\x00') result += '\x00';
            else if (str[i + 1] == '\n') result += '\r';
            else result += '\x00' + str[i + 1];
            i++;
          } else result += str[i];
        }
        return result + (i < str.length ? str[str.length - 1] : '');
        //return str.replace(/\x00\n/g, '\r').replace(/\x00\x00/g, '\x00');
      }
      
      function BinaryStringToU8Arr(str) {
        let arr = new Uint8Array(str.length);
        for (var i = 0; i < str.length; i++) arr[i] = str.charCodeAt(i);
        return arr;
      }
      
      function U8ArrToBinaryString(arr) {
        if (arr instanceof ArrayBuffer) arr = new Uint8Array(arr);
        let str = '';
        for (var i = 0; i < arr.length; i++) str += String.fromCharCode(arr[i]);
        return str;
      }
      
      async function Update(mode) {
        if (text_unhashed.classList.contains('is-invalid')) {
          text_unhashed.classList.remove('is-invalid');
          text_unhashed_warning.style.display = 'none';
          text_unhashed_warning.innerText = '';
        }
        
        let repeatCount = Number(repeats.value);
        if (Number.isNaN(repeatCount)) { repeatCount = 1; repeats.value = 1; }
        else if (repeatCount < 1) { if (repeats.value != '') { repeatCount = 1; repeats.value = 1; } else { repeatCount = 1; } }
        else if (!Number.isSafeInteger(repeatCount)) { repeatCount = Math.round(repeatCount); repeats.value = repeatCount; }
        
        switch (hash_algorythm.value) {
          case 'SHA-1': case 'SHA-256': case 'SHA-384': case 'SHA-512':
          case 'SHA-224': case 'SHA-512_224': case 'SHA-512_256':
          case 'SHA3-224': case 'SHA3-256': case 'SHA3-384': case 'SHA3-512':
            output_length_div.style.display = 'none';
            function_name_div.style.display = 'none';
            customization_div.style.display = 'none';
            hash_header.innerText = 'SHA';
            break;
          
          case 'Keccak-224': case 'Keccak-256': case 'Keccak-384': case 'Keccak-512':
            output_length_div.style.display = 'none';
            function_name_div.style.display = 'none';
            customization_div.style.display = 'none';
            hash_header.innerText = 'Keccak';
            break;
          
          case 'SHAKE-128': case 'SHAKE-256':
            output_length_div.style.display = 'flex';
            function_name_div.style.display = 'none';
            customization_div.style.display = 'none';
            hash_header.innerText = 'SHAKE';
            break;
          
          case 'CSHAKE-128': case 'CSHAKE-256':
            output_length_div.style.display = 'flex';
            function_name_div.style.display = 'flex';
            customization_div.style.display = 'flex';
            hash_header.innerText = 'CSHAKE';
            break;
        }
        
        if (mode == 2) return;
        
        if (!auto_convert.checked && !mode) return;
        
        try {
          let binaryString = TextAreaToText(text_unhashed.value);
          
          switch (text_encoding.value) {
            case 'utf8': binaryString = Utf8ToLatin1(binaryString); break;
            case 'utf16le': binaryString = Utf16LEToLatin1(binaryString); break;
            case 'utf16lenb': binaryString = Utf16LENBToLatin1(binaryString); break;
            case 'utf16be': binaryString = Utf16BEToLatin1(binaryString); break;
            case 'utf16benb': binaryString = Utf16BENBToLatin1(binaryString); break;
            case 'base64': binaryString = atob(binaryString); break;
            case 'hex': binaryString = HexToBinaryString(binaryString); break;
          }
          
          binaryString = BinaryStringToU8Arr(binaryString);
          
          switch (hash_algorythm.value) {
            case 'SHA-1': case 'SHA-256': case 'SHA-384': case 'SHA-512':
              for (var i = 0; i < repeatCount; i++) binaryString = await crypto.subtle.digest(hash_algorythm.value, binaryString);
              break;
            
            case 'SHA-224': case 'SHA-512_224': case 'SHA-512_256':
              let alg = window[hash_algorythm.value.replace('-', '').toLowerCase()];
              for (var i = 0; i < repeatCount; i++) binaryString = BinaryStringToU8Arr(HexToBinaryString(alg(binaryString)));
              break;
            
            case 'SHA3-224': case 'SHA3-256': case 'SHA3-384': case 'SHA3-512':
            case 'Keccak-224': case 'Keccak-256': case 'Keccak-384': case 'Keccak-512': {
              let alg = window[hash_algorythm.value.replace('-', '_').toLowerCase()];
              for (var i = 0; i < repeatCount; i++) binaryString = BinaryStringToU8Arr(HexToBinaryString(alg(binaryString)));
              } break;
            
            case 'SHAKE-128': case 'SHAKE-256': {
              let outputLength = Number(output_length.value);
              if (Number.isNaN(outputLength)) { outputLength = 0; output_length.value = 0; }
              else if (outputLength < 0) { if (output_length.value != '') { outputLength = 0; output_length.value = 0; } else { outputLength = 0; } }
              else if (!Number.isSafeInteger(outputLength)) { outputLength = Math.round(outputLength); output_length.value = outputLength; }
              
              let alg = window[hash_algorythm.value.replace('-', '').toLowerCase()];
              for (var i = 0; i < repeatCount; i++) binaryString = BinaryStringToU8Arr(HexToBinaryString(alg(binaryString, output_length.value)));
              } break;
            
            case 'CSHAKE-128': case 'CSHAKE-256': {
              let outputLength = Number(output_length.value), functionName, customizationStr;
              if (Number.isNaN(outputLength)) { outputLength = 0; output_length.value = 0; }
              else if (outputLength < 0) { if (output_length.value != '') { outputLength = 0; output_length.value = 0; } else { outputLength = 0; } }
              else if (!Number.isSafeInteger(outputLength)) { outputLength = Math.round(outputLength); output_length.value = outputLength; }
              if (function_name_check.checked) {
                functionName = TextAreaToText(function_name.value);
                switch (function_name_format.value) {
                  case 'utf8': functionName = Utf8ToLatin1(functionName); break;
                  case 'utf16be': functionName = Utf16BEToLatin1(functionName); break;
                  case 'utf16benb': functionName = Utf16BENBToLatin1(functionName); break;
                  case 'utf16le': functionName = Utf16LEToLatin1(functionName); break;
                  case 'utf16lenb': functionName = Utf16LENBToLatin1(functionName); break;
                  case 'base64': functionName = atob(functionName); break;
                  case 'hex': functionName = HexToBinaryString(functionName); break;
                }
                functionName = BinaryStringToU8Arr(functionName);
              }
              if (customization_check.checked) {
                customizationStr = TextAreaToText(customization.value);
                switch (customization_format.value) {
                  case 'utf8': customizationStr = Utf8ToLatin1(customizationStr); break;
                  case 'utf16be': customizationStr = Utf16BEToLatin1(customizationStr); break;
                  case 'utf16benb': customizationStr = Utf16BENBToLatin1(customizationStr); break;
                  case 'utf16le': customizationStr = Utf16LEToLatin1(customizationStr); break;
                  case 'utf16lenb': customizationStr = Utf16LENBToLatin1(customizationStr); break;
                  case 'base64': customizationStr = atob(customizationStr); break;
                  case 'hex': customizationStr = HexToBinaryString(customizationStr); break;
                }
                customizationStr = BinaryStringToU8Arr(customizationStr);
              }
              
              let alg = window[hash_algorythm.value.replace('-', '').toLowerCase()];
              for (var i = 0; i < repeatCount; i++) binaryString = BinaryStringToU8Arr(HexToBinaryString(alg(binaryString, output_length.value, function_name_check.checked ? functionName : '', customization_check.checked ? customizationStr : '')));
              } break;
          }
          
          binaryString = U8ArrToBinaryString(binaryString);
          
          switch (output_encoding.value) {
            case 'latin1': text_hashed.value = TextToTextArea(binaryString); break;
            case 'base64': text_hashed.value = btoa(binaryString); break;
            case 'hex': text_hashed.value = BinaryStringToHex(binaryString); break;
          }
        } catch (e) {
          if (!text_unhashed.classList.contains('is-invalid')) text_unhashed.classList.add('is-invalid');
          text_unhashed_warning.innerText = e instanceof DOMException ? 'Invalid char sequence' : (console.error(e), e.toString());
          text_unhashed_warning.style.display = '';
        }
      }
      
      function OutputLengthUpdate(evt) {
        if (evt.key != 'ArrowUp' && evt.key != 'ArrowDown' && evt.type != 'wheel') return;
        let outputLength = Number(output_length.value) + (evt.key == 'ArrowUp' || evt.deltaY < 0 ? 1 : -1);
        if (outputLength % 8 == 1) { outputLength += 6; output_length.value = outputLength; }
        else if (outputLength % 8 == 7) { outputLength -= 6; output_length.value = outputLength; }
      }
      
      output_length.onkeydown = output_length.onwheel = OutputLengthUpdate;
      
      text_unhashed.ondragover = evt => evt.preventDefault();
      text_unhashed.ondrop = evt => {
        evt.preventDefault();
        if (evt.dataTransfer && evt.dataTransfer.files.length) {
          let reader = new FileReader();
          
          reader.onload = e => {
            text_encoding.value = 'latin1';
            text_unhashed.value = TextToTextArea(e.target.result);
            Update();
          };
          
          reader.readAsBinaryString(evt.dataTransfer.files[0]);
        }
      };
      
      text_hashed.ondragover = evt => evt.preventDefault();
      text_hashed.ondrop = evt => {
        evt.preventDefault();
        if (evt.dataTransfer && evt.dataTransfer.files.length) {
          let reader = new FileReader();
          
          reader.onload = e => {
            text_hashed.value = e.target.result;
          };
          
          reader.readAsText(evt.dataTransfer.files[0]);
        }
      };
      
      var setTextIsHashed;
      
      file_to_load.oninput = evt => {
        if (setTextIsHashed) {
          let reader = new FileReader();
          
          reader.onload = e => {
            text_hashed.value = e.target.result;
          };
          
          reader.readAsText(evt.target.files[0]);
        } else {
          let reader = new FileReader();
          
          reader.onload = e => {
            text_encoding.value = 'latin1';
            text_unhashed.value = TextToTextArea(e.target.result);
            Update();
          };
          
          reader.readAsBinaryString(evt.target.files[0]);
        }
      };
      
      function SetTextToFile() {
        setTextIsHashed = false;
        file_to_load.click();
      }
      
      function SetHashedTextToFile() {
        setTextIsHashed = true;
        file_to_load.click();
      }
      
      function DownloadTextAsFile() {
        let element = document.createElement('a');
        
        switch (text_encoding.value) {
          case 'utf8': element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(TextAreaToText(text_unhashed.value))); break;
          case 'utf16le': element.setAttribute('href', 'data:text/plain;base64,' + btoa(Utf16LEToLatin1(TextAreaToText(text_unhashed.value)))); break;
          case 'utf16lenb': element.setAttribute('href', 'data:text/plain;base64,' + btoa(Utf16LENBToLatin1(TextAreaToText(text_unhashed.value)))); break;
          case 'utf16be': element.setAttribute('href', 'data:text/plain;base64,' + btoa(Utf16BEToLatin1(TextAreaToText(text_unhashed.value)))); break;
          case 'utf16benb': element.setAttribute('href', 'data:text/plain;base64,' + btoa(Utf16BENBToLatin1(TextAreaToText(text_unhashed.value)))); break;
          case 'latin1': element.setAttribute('href', 'data:application/octet-stream;base64,' + btoa(TextAreaToText(text_unhashed.value))); break;
          case 'base64': element.setAttribute('href', 'data:application/octet-stream;base64,' + text_unhashed.value); break;
          case 'hex': element.setAttribute('href', 'data:application/octet-stream;base64,' + btoa(HexToBinaryString(text_unhashed.value))); break;
        }
        
        element.setAttribute('download', 'file.txt');
        
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      }
      
      function DownloadHashedTextAsFile() {
        let element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + text_unhashed.value);
        element.setAttribute('download', 'file.txt');
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      }
      
      onload = () => {
        Update();
      };
    </script>
  </body>
</html>
