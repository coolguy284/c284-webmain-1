<!doctype html>
<html lang = 'en'>
  <head>
    <meta charset = 'utf-8'>
    
    <title>coolguy284.com: Time Syncer 2</title>
    
    <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0'>
    <meta name = 'description' content = 'This page continuously calculates the difference between the time of the server and the client in order to show the server time.'>
    <meta name = 'keywords' content = 'tools'>
    <meta name = 'author' content = 'coolguy284'>
    
    <link rel = 'canonical' href = 'https://coolguy284.com/misc/debug/time_syncer_2.html'>
    
    <meta name = 'og:title' content = 'coolguy284.com: Time Syncer 2'>
    <meta name = 'og:description' content = 'This page continuously calculates the difference between the time of the server and the client in order to show the server time.'>
    <meta name = 'og:type' content = 'website'>
    <meta name = 'og:url' content = 'https://coolguy284.com/misc/debug/time_syncer_2.html'>
    
    <style>
      html {
        font-family: Arial, sans-serif;
      }
      
      span {
        font-family: Consolas, monospace;
      }
    </style>
  </head>
  
  <body>
    <h1>Info</h1>
    <p>This page calculates the difference between the time of the server and the client in order to show the server time.</p>
    
    <h1>Data</h1>
    <p>Client Time: <span id = 'client_time'>-</span></p>
    <p>Server Time: <span id = 'server_time'>-</span></p>
    <p>Client - Server: <span id = 'client_minus_server_time'>-</span> ms, slew: <span id = 'client_minus_server_time_slew'>-</span> &micro;s/s</p>
    <p>Latency To Server: <span id = 'server_latency'>-</span> ms</p>
    <p>Samples: <span id = 'samples'>-</span> (<span id = 'max_samples'>-</span> max)</p>
    <p>Total Ticks: <span id = 'total_ticks'>-</span></p>
    <p><span id = 'connection_status'>Code Not Running</span></p>
    <button id = 'status_toggle' onclick = 'toggleTimeUpdateLoop();'>Start / Stop</button>
    
    <script>
      let TIME_PING_URL = '/api/query/current_time?form=number';
      let DUMMY_MODE = location.origin == 'null';
      let PING_INTERVAL_MS = 500;
      let MAX_SAMPLES = 100;
      let IGNORED_START_SAMPLES = 2;
      let ARTIFICIAL_LATENCY = 0;
      let DUMMY_LATENCY = 100;
      let DUMMY_OFFSET = 10;
      let DUMMY_OFFSET_SLEW = 0.1;
      let DUMMY_ERROR_PROBABILITY = 0.1;
      
      class SampleAverager {
        #maxSamples;
        #samples = [0];
        #currentSampleIndex = -2;
        #sampleAverage = 0;
        
        constructor(maxSamples, ignoredStartSamples) {
          this.#maxSamples = maxSamples;
          this.#currentSampleIndex = -ignoredStartSamples;
        }
        
        newSampleInput(sample) {
          if (this.#currentSampleIndex < 0) {
            this.#currentSampleIndex++;
          } else {
            if (this.#currentSampleIndex in this.#samples) {
              this.#sampleAverage -= this.#samples[this.#currentSampleIndex] / this.#samples.length;
            } else {
              this.#sampleAverage *= this.#samples.length / (this.#samples.length + 1);
            }
            this.#samples[this.#currentSampleIndex] = sample;
            this.#sampleAverage += this.#samples[this.#currentSampleIndex] / this.#samples.length;
            
            this.#currentSampleIndex++;
            if (this.#currentSampleIndex >= this.#samples.length) {
              if (this.#samples.length >= this.#maxSamples) {
                this.#currentSampleIndex = 0;
              }
            }
          }
        }
        
        getSampleAverage() {
          return this.#sampleAverage;
        }
        
        numSamples() {
          return this.#samples.length;
        }
      }
      
      let guiLoopRunning = false;
      let timeUpdateLoopRunning = false;
      let currentClientOffset = 0;
      let pastClientOffset = currentClientOffset;
      let currentClientOffsetSlew = 0;
      let roundTripMSSamples = new SampleAverager(MAX_SAMPLES, IGNORED_START_SAMPLES);
      let clientDiffMSSamples = new SampleAverager(MAX_SAMPLES, IGNORED_START_SAMPLES);
      let clientDiffSlewMSSamples = new SampleAverager(MAX_SAMPLES, IGNORED_START_SAMPLES);
      
      if (DUMMY_MODE) {
        window.startTime = Date.now();
      }
      
      async function getServerTime() {
        return await new Promise((r, j) => {
          if (DUMMY_MODE) {
            setTimeout(() => {
              let error = false;
              if (DUMMY_ERROR_PROBABILITY > 0) {
                error = Math.random() < DUMMY_ERROR_PROBABILITY;
              }
              if (error) {
                j(new Error('XHR Dummy Error'));
              } else {
                r({
                  roundTripMS: DUMMY_LATENCY,
                  clientDiffMS: DUMMY_OFFSET + (Date.now() - window.startTime) / 1000 * DUMMY_OFFSET_SLEW,
                });
              }
            }, DUMMY_LATENCY);
          } else {
            let requestStartClientTimeMS = Date.now();
            
            if (ARTIFICIAL_LATENCY > 0) {
              setTimeout(() => {
                getServerTimeStartProcessing(r, j, requestStartClientTimeMS);
              }, ARTIFICIAL_LATENCY);
            } else {
              getServerTimeStartProcessing(r, j, requestStartClientTimeMS);
            }
          }
        });
      }
      
      function getServerTimeStartProcessing(r, j, requestStartClientTimeMS) {
        let request = new XMLHttpRequest();
        request.open('GET', TIME_PING_URL);
        request.send();
        request.addEventListener('load', () => {
          if (ARTIFICIAL_LATENCY > 0) {
            setTimeout(() => {
              getServerTimeEndProcessing(r, requestStartClientTimeMS, request);
            }, ARTIFICIAL_LATENCY);
          } else {
            getServerTimeEndProcessing(r, requestStartClientTimeMS, request);
          }
        }, true);
        request.addEventListener('error', () => {
          j(new Error('XHR Error'));
        });
        request.addEventListener('abort', () => {
          j(new Error('XHR Abort'));
        });
        request.addEventListener('timeout', () => {
          j(new Error('XHR Timeout'));
        });
      }
      
      function getServerTimeEndProcessing(r, requestStartClientTimeMS, request) {
        let requestEndClientTimeMS = Date.now();
        let requestMiddleClientTimeMS = (requestEndClientTimeMS + requestStartClientTimeMS) / 2;
        let requestMiddleServerTimeMS = Number(request.responseText);
        
        let roundTripMS = requestEndClientTimeMS - requestStartClientTimeMS;
        let clientDiffMS = requestMiddleClientTimeMS - requestMiddleServerTimeMS;
        
        r({
          roundTripMS,
          clientDiffMS,
        });
      }
      
      function dateToString(date) {
        let str = date.toString();
        
        let [ timeStr, utcOffsetStr ] = str.split(' GMT');
        
        return `${timeStr}.${(date.getMilliseconds() + '').padStart(3, '0')} GMT${utcOffsetStr}`;
      }
      
      function msToString(ms) {
        let prefix = ms < 0 ? '-' : '+';
        
        ms = Math.abs(ms);
        
        let [ int, frac ] = ms.toFixed(3).split('.');
        
        return `${prefix}${int}.${frac}`;
      }
      
      async function guiLoop() {
        if (guiLoopRunning) return;
        
        guiLoopRunning = true;
        
        while (guiLoopRunning) {
          let clientNow = new Date();
          let serverNow = new Date(clientNow.getTime() - currentClientOffset);
          
          client_time.textContent = dateToString(clientNow);
          server_time.textContent = dateToString(serverNow);
          
          await new Promise(r => requestAnimationFrame(r));
          await new Promise(r => requestAnimationFrame(r));
        }
      }
      
      async function timeUpdateLoop() {
        if (timeUpdateLoopRunning) return;
        
        timeUpdateLoopRunning = true;
        
        let ticks = 0;
        let pastNow = Date.now();
        
        while (timeUpdateLoopRunning) {
          let now = Date.now();
          let awaitUntil = now + PING_INTERVAL_MS;
          
          try {
            let { roundTripMS, clientDiffMS } = await getServerTime();
            
            roundTripMSSamples.newSampleInput(roundTripMS);
            clientDiffMSSamples.newSampleInput(clientDiffMS);
            
            currentClientOffset = clientDiffMSSamples.getSampleAverage();
            let trueTickTime = now - pastNow;
            if (trueTickTime != 0) {
              clientDiffSlewMSSamples.newSampleInput((currentClientOffset - pastClientOffset) / trueTickTime * 1000);
            }
            currentClientOffsetSlew = clientDiffSlewMSSamples.getSampleAverage();
            
            client_minus_server_time.textContent = msToString(currentClientOffset);
            client_minus_server_time_slew.textContent = msToString(currentClientOffsetSlew * 1000);
            server_latency.textContent = msToString(roundTripMSSamples.getSampleAverage());
            samples.textContent = roundTripMSSamples.numSamples();
            max_samples.textContent = MAX_SAMPLES;
          } catch { /* empty */ }
          
          total_ticks.textContent = ++ticks;
          
          pastClientOffset = currentClientOffset;
          pastNow = now;
          
          let timeLeft = awaitUntil - Date.now();
          if (timeLeft > 0) {
            await new Promise(r => setTimeout(r, timeLeft));
          }
        }
      }
      
      function toggleTimeUpdateLoop() {
        if (!timeUpdateLoopRunning) {
          timeUpdateLoop();
          
          connection_status.textContent = DUMMY_MODE ? 'Connected (Dummy)' : 'Connected';
        } else {
          timeUpdateLoopRunning = false;
          
          connection_status.textContent = 'Code Not Running';
        }
      }
      
      guiLoop();
      toggleTimeUpdateLoop();
    </script>
  </body>
</html>
