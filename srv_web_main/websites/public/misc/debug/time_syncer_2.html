<!doctype html>
<html lang = 'en'>
  <head>
    <meta charset = 'utf-8'>
    
    <title>coolguy284.com: Time Syncer 2</title>
    
    <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0'>
    <meta name = 'description' content = 'This page continuously calculates the difference between the time of the server and the client in order to show the server time.'>
    <meta name = 'keywords' content = 'tools'>
    <meta name = 'author' content = 'coolguy284'>
    
    <link rel = 'canonical' href = 'https://coolguy284.com/misc/debug/time_syncer_2.html'>
    
    <meta name = 'og:title' content = 'coolguy284.com: Time Syncer 2'>
    <meta name = 'og:description' content = 'This page continuously calculates the difference between the time of the server and the client in order to show the server time.'>
    <meta name = 'og:type' content = 'website'>
    <meta name = 'og:url' content = 'https://coolguy284.com/misc/debug/time_syncer_2.html'>
    
    <style>
      html {
        font-family: Arial, sans-serif;
      }
      
      button {
        margin-bottom: 1rem;
      }
      
      input[type = range] {
        position: relative;
        top: 0.4rem;
        margin-right: 0.2rem;
      }
      
      input[type = text] {
        width: 3rem;
        font-size: 1rem;
      }
      
      .mono {
        font-family: Consolas, monospace;
      }
      
      .small_btm_margin {
        margin-bottom: 0.5rem;
      }
    </style>
  </head>
  
  <body>
    <h1>Info</h1>
    <p>This page calculates the difference between the time of the server and the client in order to show the server time.</p>
    
    <h1>Data</h1>
    <p>Client Time: <span id = 'client_time' class = 'mono'>-</span></p>
    <p>Server Time: <span id = 'server_time' class = 'mono'>-</span></p>
    <p class = 'small_btm_margin'><span id = 'rendering_status' class = 'mono'>-</span></p>
    <div>
      <span>Frame Skip:</span>
      <!-- https://stackoverflow.com/questions/18544890/onchange-event-on-input-type-range-is-not-triggering-in-firefox-while-dragging -->
      <input type = 'range' id = 'render_frame_skips' min = 1 max = 15 step = 1 value = 2 oninput = 'updateFrameSkip(this);'>
      <input type = 'text' id = 'render_frame_skips_text' value = 2 onchange = 'updateFrameSkip(this);'>
    </div>
    <br>
    <button id = 'status_toggle' onclick = 'toggleGuiLoop();'>Start / Stop Rendering</button>
    <hr>
    <p>Client - Server: <span id = 'client_minus_server_time' class = 'mono'>-</span> ms</p>
    <p>Slew: <span id = 'client_minus_server_time_slew' class = 'mono'>-</span> &micro;s/s</p>
    <p>ETA till <input type = 'text' id = 'eta_till_close_target' value = 0 onchange = 'updateEtaTillClose(this);'>ms &PlusMinus; <input type = 'text' id = 'eta_till_close_tolerance' value = 25 onchange = 'updateEtaTillClose(this);'>ms: <span id = 'eta_till_close' class = 'mono'>-</span></p>
    <p>Latency To Server: <span id = 'server_latency' class = 'mono'>-</span> ms</p>
    <p>Samples: <span id = 'samples' class = 'mono'>-</span> (<span id = 'max_samples' class = 'mono'>-</span> max)</p>
    <p>Total Ticks: <span id = 'total_ticks' class = 'mono'>-</span></p>
    <p><span id = 'connection_status' class = 'mono'>Code Not Running</span><span id = 'connection_dummy' class = 'mono'></span></p>
    <button id = 'status_toggle' onclick = 'toggleTimeUpdateLoop();'>Start / Stop Syncing</button>
    
    <script>
      let TIME_PING_URL = '/api/query/current_time?form=number';
      let DUMMY_MODE = location.origin == 'null';
      let PING_INTERVAL_MS = 500;
      let MAX_SAMPLES = 100;
      let IGNORED_START_SAMPLES = 2;
      let DO_DISCONNECTED_CHECK = true;
      let DISCONNECTED_TIMEOUT = 2000;
      let ARTIFICIAL_LATENCY = 0;
      let DUMMY_LATENCY = 100;
      let DUMMY_OFFSET = 30;
      let DUMMY_OFFSET_SLEW = -0.1;
      let DUMMY_ERROR_PROBABILITY = 0;
      let RENDER_FRAME_SKIPS = 2;
      let CLOSE_OFFSET_TARGET = 0;
      let CLOSE_OFFSET_TOLERANCE = 25;
      
      class SampleAverager {
        #maxSamples;
        #samples = [0];
        #currentSampleIndex = -2;
        #sampleAverage = 0;
        
        constructor(maxSamples, ignoredStartSamples) {
          this.#maxSamples = maxSamples;
          this.#currentSampleIndex = -ignoredStartSamples;
        }
        
        newSampleInput(sample) {
          if (this.#currentSampleIndex < 0) {
            this.#currentSampleIndex++;
          } else {
            if (this.#currentSampleIndex in this.#samples) {
              this.#sampleAverage -= this.#samples[this.#currentSampleIndex] / this.#samples.length;
            } else {
              this.#sampleAverage *= this.#samples.length / (this.#samples.length + 1);
            }
            this.#samples[this.#currentSampleIndex] = sample;
            this.#sampleAverage += this.#samples[this.#currentSampleIndex] / this.#samples.length;
            
            this.#currentSampleIndex++;
            if (this.#currentSampleIndex >= this.#samples.length) {
              if (this.#samples.length >= this.#maxSamples) {
                this.#currentSampleIndex = 0;
              }
            }
          }
        }
        
        getSampleAverage() {
          return this.#sampleAverage;
        }
        
        numSamples() {
          return this.#samples.length;
        }
      }
      
      let guiLoopRunning = false;
      let timeUpdateLoopRunning = false;
      let currentClientOffset = 0;
      let pastClientOffset = currentClientOffset;
      let currentClientOffsetSlew = 0;
      let roundTripMSSamples = new SampleAverager(MAX_SAMPLES, IGNORED_START_SAMPLES);
      let clientDiffMSSamples = new SampleAverager(MAX_SAMPLES, IGNORED_START_SAMPLES);
      let clientDiffSlewMSSamples = new SampleAverager(MAX_SAMPLES, IGNORED_START_SAMPLES);
      
      if (DUMMY_MODE) {
        window.startTime = Date.now();
      }
      
      async function getServerTime() {
        return await new Promise((r, j) => {
          if (DUMMY_MODE) {
            setTimeout(() => {
              let error = false;
              if (DUMMY_ERROR_PROBABILITY > 0) {
                if (DUMMY_ERROR_PROBABILITY >= 1) {
                  error = true;
                } else {
                  error = Math.random() <= DUMMY_ERROR_PROBABILITY;
                }
              }
              if (error) {
                j(new Error('XHR Dummy Error'));
              } else {
                r({
                  roundTripMS: DUMMY_LATENCY,
                  clientDiffMS: DUMMY_OFFSET + (Date.now() - window.startTime) / 1000 * DUMMY_OFFSET_SLEW,
                });
              }
            }, DUMMY_LATENCY);
          } else {
            let requestStartClientTimeMS = Date.now();
            
            if (ARTIFICIAL_LATENCY > 0) {
              setTimeout(() => {
                getServerTimeStartProcessing(r, j, requestStartClientTimeMS);
              }, ARTIFICIAL_LATENCY);
            } else {
              getServerTimeStartProcessing(r, j, requestStartClientTimeMS);
            }
          }
        });
      }
      
      function getServerTimeStartProcessing(r, j, requestStartClientTimeMS) {
        let request = new XMLHttpRequest();
        request.open('GET', TIME_PING_URL);
        request.send();
        request.addEventListener('load', () => {
          if (ARTIFICIAL_LATENCY > 0) {
            setTimeout(() => {
              getServerTimeEndProcessing(r, requestStartClientTimeMS, request);
            }, ARTIFICIAL_LATENCY);
          } else {
            getServerTimeEndProcessing(r, requestStartClientTimeMS, request);
          }
        }, true);
        request.addEventListener('error', () => {
          j(new Error('XHR Error'));
        });
        request.addEventListener('abort', () => {
          j(new Error('XHR Abort'));
        });
        request.addEventListener('timeout', () => {
          j(new Error('XHR Timeout'));
        });
      }
      
      function getServerTimeEndProcessing(r, requestStartClientTimeMS, request) {
        let requestEndClientTimeMS = Date.now();
        let requestMiddleClientTimeMS = (requestEndClientTimeMS + requestStartClientTimeMS) / 2;
        let requestMiddleServerTimeMS = Number(request.responseText);
        
        let roundTripMS = requestEndClientTimeMS - requestStartClientTimeMS;
        let clientDiffMS = requestMiddleClientTimeMS - requestMiddleServerTimeMS;
        
        r({
          roundTripMS,
          clientDiffMS,
        });
      }
      
      function dateToString(date) {
        let str = date.toString();
        
        let [ timeStr, utcOffsetStr ] = str.split(' GMT');
        
        return `${timeStr}.${(date.getMilliseconds() + '').padStart(3, '0')} GMT${utcOffsetStr}`;
      }
      
      function msToString(ms) {
        let prefix = ms < 0 ? '-' : '+';
        
        ms = Math.abs(ms);
        
        let [ int, frac ] = ms.toFixed(3).split('.');
        
        return `${prefix}${int}.${frac}`;
      }
      
      function hmsToString(secs) {
        if (secs < 0) {
          return `-${hmsToString(-secs)}`;
        } else {
          return `${Math.floor(secs / 3600)}h ${Math.floor(secs / 60 % 60)}m ${Math.floor(secs % 60)}s`;
        }
      }
      
      async function guiLoop() {
        if (guiLoopRunning) return;
        
        guiLoopRunning = true;
        
        while (guiLoopRunning) {
          let clientNow = new Date();
          let serverNow = new Date(clientNow.getTime() - currentClientOffset);
          
          client_time.textContent = dateToString(clientNow);
          server_time.textContent = dateToString(serverNow);
          
          if (RENDER_FRAME_SKIPS > 0) {
            for (let i = 0; i < RENDER_FRAME_SKIPS; i++) {
              await new Promise(r => requestAnimationFrame(r));
              if (!guiLoopRunning) break;
            }
          } else {
            await new Promise(r => requestAnimationFrame(r));
          }
        }
      }
      
      function toggleGuiLoop() {
        if (!guiLoopRunning) {
          guiLoop();
          
          rendering_status.textContent = 'Rendering';
        } else {
          guiLoopRunning = false;
          
          rendering_status.textContent = 'Not Rendering';
        }
      }
      
      function updateFrameSkip(elem) {
        switch (elem.type) {
          case 'range':
            RENDER_FRAME_SKIPS = Number(elem.value);
            render_frame_skips_text.value = RENDER_FRAME_SKIPS;
            break;
          
          case 'text': {
            let newVal = Number(elem.value);
            if (Number.isSafeInteger(newVal)) {
              RENDER_FRAME_SKIPS = newVal;
              render_frame_skips.value = RENDER_FRAME_SKIPS;
            }
            } break;
        }
      }
      
      async function timeUpdateLoop() {
        if (timeUpdateLoopRunning) return;
        
        timeUpdateLoopRunning = true;
        
        let ticks = 0;
        let pastNow = Date.now();
        let errorTimeout = null;
        let noError = null;
        let pastNoError = noError;
        let startDisconnectedTicks = null;
        
        while (timeUpdateLoopRunning) {
          if (DO_DISCONNECTED_CHECK && (noError || noError == null || errorTimeout == null)) {
            if (errorTimeout != null) {
              clearTimeout(errorTimeout);
              errorTimeout = null;
            }
            errorTimeout = setTimeout(() => {
              if (timeUpdateLoopRunning) {
                if (startDisconnectedTicks == null) {
                  startDisconnectedTicks = ticks;
                }
                connection_status.textContent = `Disconnected ${((ticks - startDisconnectedTicks) * PING_INTERVAL_MS / 1000).toFixed(0)}s`;
              }
              errorTimeout = null;
            }, DISCONNECTED_TIMEOUT);
          }
          
          let now = Date.now();
          let awaitUntil = now + PING_INTERVAL_MS;
          if (DO_DISCONNECTED_CHECK) noError = false;
          
          try {
            let { roundTripMS, clientDiffMS } = await getServerTime();
            
            roundTripMSSamples.newSampleInput(roundTripMS);
            clientDiffMSSamples.newSampleInput(clientDiffMS);
            
            currentClientOffset = clientDiffMSSamples.getSampleAverage();
            let trueTickTime = now - pastNow;
            if (trueTickTime != 0) {
              clientDiffSlewMSSamples.newSampleInput((currentClientOffset - pastClientOffset) / trueTickTime * 1000);
            }
            currentClientOffsetSlew = clientDiffSlewMSSamples.getSampleAverage();
            
            client_minus_server_time.textContent = msToString(currentClientOffset);
            client_minus_server_time_slew.textContent = msToString(currentClientOffsetSlew * 1000);
            
            let closeStatus = null;
            if (Number.isNaN(CLOSE_OFFSET_TARGET)) {
              closeStatus = 'Target NaN';
            } else if (Number.isNaN(CLOSE_OFFSET_TOLERANCE)) {
              closeStatus = 'Threshold NaN';
            } else {
              let shiftedAbsCurrentClientOffset = currentClientOffset - CLOSE_OFFSET_TARGET,
                maybeFlippedCurrentClientOffsetSlew;
              if (shiftedAbsCurrentClientOffset < 0) {
                shiftedAbsCurrentClientOffset = -shiftedAbsCurrentClientOffset;
                maybeFlippedCurrentClientOffsetSlew = -currentClientOffsetSlew;
              } else {
                maybeFlippedCurrentClientOffsetSlew = currentClientOffsetSlew;
              }
              if (shiftedAbsCurrentClientOffset > CLOSE_OFFSET_TOLERANCE) {
                let etaTillCloseSecs = (shiftedAbsCurrentClientOffset - CLOSE_OFFSET_TOLERANCE) / -maybeFlippedCurrentClientOffsetSlew;
                if (etaTillCloseSecs < 0) {
                  closeStatus = 'NEVER';
                } else {
                  closeStatus = hmsToString(etaTillCloseSecs);
                }
              } else {
                let fracToBoundary = shiftedAbsCurrentClientOffset / CLOSE_OFFSET_TOLERANCE;
                closeStatus = `REACHED (${(fracToBoundary * 100).toFixed(1)}% to boundary)`;
              }
            }
            eta_till_close.textContent = closeStatus;
            
            server_latency.textContent = msToString(roundTripMSSamples.getSampleAverage());
            samples.textContent = roundTripMSSamples.numSamples();
            max_samples.textContent = MAX_SAMPLES;
            
            if (DO_DISCONNECTED_CHECK) {
              noError = true;
              startDisconnectedTicks = null;
            }
          } catch (e) {
            if (!e.toString().startsWith('Error: XHR')) {
              throw e;
            }
          }
          
          if (DO_DISCONNECTED_CHECK && noError) {
            if (errorTimeout != null) {
              clearTimeout(errorTimeout);
              errorTimeout = null;
            }
            
            if (errorTimeout == null || pastNoError == null) {
              // error state was set, but since successful, unset error status
              if (timeUpdateLoopRunning) {
                connection_status.textContent = 'Connected';
              }
            }
          }
          
          ticks++;
          total_ticks.textContent = ticks;
          
          pastClientOffset = currentClientOffset;
          pastNow = now;
          if (DO_DISCONNECTED_CHECK) pastNoError = noError;
          
          let timeLeft = awaitUntil - Date.now();
          if (timeLeft > 0) {
            await new Promise(r => setTimeout(r, timeLeft));
          }
        }
      }
      
      function toggleTimeUpdateLoop() {
        if (DUMMY_MODE) {
          connection_dummy.textContent = ' (Dummy)';
        } else {
          connection_dummy.textContent = '';
        }
        if (!timeUpdateLoopRunning) {
          timeUpdateLoop();
          
          if (DO_DISCONNECTED_CHECK) {
            connection_status.textContent = 'Starting';
          } else {
            connection_status.textContent = 'Connected';
          }
        } else {
          timeUpdateLoopRunning = false;
          
          connection_status.textContent = 'Code Not Running';
        }
      }
      
      function updateEtaTillClose(elem) {
        switch (elem) {
          case eta_till_close_target:
            CLOSE_OFFSET_TARGET = Number(eta_till_close_target.value);
            break;
          
          case eta_till_close_tolerance:
            CLOSE_OFFSET_TOLERANCE = Number(eta_till_close_tolerance.value);
            break;
        }
      }
      
      toggleGuiLoop();
      toggleTimeUpdateLoop();
    </script>
  </body>
</html>
